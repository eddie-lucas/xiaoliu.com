import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as n,e}from"./app-3d4993ca.js";const l="/assets/1699946002321-dce663da-ec21-4396-9b6d-adabcaae90c2-24ff6162.png",i="/assets/1699963669837-05db9b54-507c-484b-b008-561b94a21b2e-f605bd7a.png",o="/assets/1699963934778-3ef44350-9611-4de8-84e3-6eaa7356627e-d8531ad9.png",t="/assets/1699964113891-2d517a25-5a08-4ef5-b70d-0b755dbfacba-747da1a3.png",d="/assets/1699965090639-afbcfbd2-06d5-41eb-9b03-f7c7eac02f1b-da364470.png",r="/assets/1699965293504-22a37f00-609c-4735-a584-2e377b8eda05-18684ec6.png",c={},p=e(`<h2 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁" aria-hidden="true">#</a> 全局锁</h2><p>全局锁主要应用于全库逻辑备份，加了全局锁之后，整个数据库处于只读状态，备份期间，会造成业务停摆，可以通过以下语句进行加锁：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果要释放全局锁，执行：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">unlock</span> <span class="token keyword">tables</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>使用全局锁会造成业务停摆，如何避免？</p></blockquote><p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。<br>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。<br>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。<br><strong>InnoDB</strong> 存储引擎默认的事务隔离级别正是可重复读，因此可以采用<strong>mysqldump</strong>的方式来备份数据库。<br>但是，对于<strong>MyISAM</strong> 这种不支持事务的引擎，在备份数据库时就要使用<strong>全局锁</strong>的方法。</p><h2 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁" aria-hidden="true">#</a> 表级锁</h2><p>MySQL表级锁有以下几种：</p><ul><li>表锁</li><li>元数据锁（MDL）</li><li>意向锁（IX，IS）</li><li>自增锁</li></ul><h3 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁" aria-hidden="true">#</a> 表锁</h3><p>加锁：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">//表级别的共享锁，也就是读锁，也称为S锁</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t_student <span class="token keyword">read</span><span class="token punctuation">;</span>

<span class="token comment">//表级别的独占锁，也就是写锁，也称为X锁</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t_stuent <span class="token keyword">write</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>释放锁：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">unlock</span> <span class="token keyword">tables</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表锁是对整张表进行加锁，粒度太大，InnoDB提供了粒度更细的行级锁</p><h3 id="元数据锁" tabindex="-1"><a class="header-anchor" href="#元数据锁" aria-hidden="true">#</a> 元数据锁</h3><p>所谓元数据，就是表的结构，比如，一张表有多少个字段，表的主键是哪个字段，每个字段的大小，这都是表的结构，元数据锁不需要我们去进行任何操作，当我们执行操作的时候，MySQL会自动进行加锁：</p><ul><li>对一张表进行CRUD操作的时候，会加上元数据读锁（因为表结构并没有改变）</li><li>对一张表的结构进行修改的时候，会加上元数据写锁（比如添加一个字段）</li></ul><p>事务执行期间，是一直持有元数据锁的，事务提交之后才会释放</p><blockquote><p>在变更表结构的时候，一定要检查数据库是否有长事务（开启了事务，但是一直还没提交）</p></blockquote><p>可能的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上元数据读锁</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为读读并不冲突</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞</li><li>线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</li></ol><p>因为申请元数据锁的操作会形成一个队列，在队列中，<strong>写锁的优先级更高</strong>，当写锁发生等待之后，后续的CRUD操作都会被阻塞</p><h3 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁" aria-hidden="true">#</a> 意向锁</h3><p>意向锁是为了避免行锁和表锁的冲突，如果没有意向锁，当加表级锁时，会进行全表扫描，看哪个记录加了锁，效率很慢，有了意向锁，在加表记锁时，直接检查是否有意向锁以及和意向锁的兼容情况就可以了，兼容即可加锁</p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上<strong>行级X锁之前</strong>，需要先在表级别加上一个<strong>IX锁</strong>；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上<strong>行级S锁之前</strong>，需要先在表级别加上一个<strong>IS锁</strong>；</li></ul><figure><img src="`+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="自增锁" tabindex="-1"><a class="header-anchor" href="#自增锁" aria-hidden="true">#</a> 自增锁</h3><p>表的主键通常会设置成自增的，之后再插入数据的时候，可以不指定主键的值，数据库会自动为主键赋值，这是通过自增锁实现的<br>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。<br><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 AUTO_INCREMENT 修饰的字段赋值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。<br>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 AUTO_INCREMENT 修饰的字段的值是连续递增的。<br>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。<br>因此，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。<br>一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。<br>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><ul><li>当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；</li><li>当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。</li><li>当 innodb_autoinc_lock_mode = 1： <ul><li>普通 insert 语句，自增锁在申请之后就马上释放；</li><li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放</li></ul></li></ul><h2 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁" aria-hidden="true">#</a> 行级锁</h2><p>InnoDB支持行级锁，MyISAM不支持，行级锁有以下几种：</p><ul><li>记录锁</li><li>间隙锁</li><li>临建锁（间隙锁+记录锁）</li><li>插入意向锁</li></ul><p>普通select语句不会对记录进行加锁，属于快照读，可以使用以下方法加锁：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">//对读取的记录加共享锁(S锁)</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>

<span class="token comment">//对读取的记录加独占锁（X锁）</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>共享锁和独占锁兼容情况如下：<br><img src="`+i+'" alt="" loading="lazy"></p><h3 id="记录锁" tabindex="-1"><a class="header-anchor" href="#记录锁" aria-hidden="true">#</a> 记录锁</h3><p>记录锁，锁的是一条记录，记录锁有S锁和X锁的区别：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><h3 id="间隙锁" tabindex="-1"><a class="header-anchor" href="#间隙锁" aria-hidden="true">#</a> 间隙锁</h3><p>间隙锁，锁住的是两条记录之间的间隙，只存在于RR隔离级别，目的是解决RR级别下的幻读问题<br>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。<br><img src="'+o+'" alt="" loading="lazy"><br>间隙锁虽然有S锁和X锁的区别，但是间隙锁之间是兼容的，因为间隙锁是为了解决幻读问题的</p><h3 id="临建锁" tabindex="-1"><a class="header-anchor" href="#临建锁" aria-hidden="true">#</a> 临建锁</h3><p>临建锁=间隙锁+记录锁，是一个<strong>前开后闭的区间</strong><br>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。<br><img src="'+t+'" alt="" loading="lazy"><br>因为记录锁存在兼容情况，因此临建锁也存在兼容情况，其兼容情况同记录所一样</p><h3 id="插入意向锁" tabindex="-1"><a class="header-anchor" href="#插入意向锁" aria-hidden="true">#</a> 插入意向锁</h3><p>一个事务在插入记录时，需要判断要插入的位置是否被其他事务添加了间隙锁（间隙锁和临建锁），如果有的话，插入操作就会被阻塞，直到事务提交，间隙锁被释放，在此期间会生成一个插入意向锁，表明某个事务想要在区间内插入记录，目前处于等待状态<br>插入意向锁是一种特殊的间隙锁，间隙锁锁住的是一个间隙，插入意向锁，锁住的是间隙中的一个点<br>虽然插入意向锁属于间隙锁，但是两个事务，不能一个拥有间隙锁，一个拥有该间隙内的插入意向锁</p><h2 id="锁的结构" tabindex="-1"><a class="header-anchor" href="#锁的结构" aria-hidden="true">#</a> 锁的结构</h2><p>对一条记录加锁，实际上是在内存中生成与之关联的锁结构，简单来看，可以这么理解：<br><img src="'+d+'" alt="" loading="lazy"></p><blockquote><p>是不是一个事务对多少条记录加锁，就生成多少个锁结构？</p></blockquote><p>理论上这么做是没有问题的，但是太占用内存空间了，如果符合以下条件，那么这些记录的锁都会被放到一个锁结构中：</p><ul><li>在同一事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',52),u=[p];function b(h,g){return s(),n("div",null,u)}const _=a(c,[["render",b],["__file","MySQL中的各种锁.html.vue"]]);export{_ as default};
