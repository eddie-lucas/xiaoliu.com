import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,e as t}from"./app-3d4993ca.js";const r={},l=t('<h2 id="redis主从复制是什么" tabindex="-1"><a class="header-anchor" href="#redis主从复制是什么" aria-hidden="true">#</a> Redis主从复制是什么？</h2><p>redis主从复制指，一个redis主节点，可以将数据复制到一个或多个redis从节点，从节点从主节点获取数据并保持同步</p><p>主从架构可以实现读写分离，写操作请求主节点，读操作请求从节点，这样就能够减轻主节点压力</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017111302650.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="旧版主从复制" tabindex="-1"><a class="header-anchor" href="#旧版主从复制" aria-hidden="true">#</a> 旧版主从复制</h2><blockquote><p>redis2.8版本之前是旧版本的主从复制，存在一些问题，先从旧版本来理解整个过程，再过渡到新版本订单主从复制</p></blockquote><p>redis的复制功能分为<strong>2个操作：同步，命令传播</strong></p><ol><li>同步：将从节点的数据库状态更新至主节点当前所处的数据库状态</li><li>命令传播：当主节点数据库状态被修改，导致主从节点的数据状态不一致，主节点将写命令发送给从节点，让主从节点的数据库重新回到一致状态</li></ol><h3 id="同步" tabindex="-1"><a class="header-anchor" href="#同步" aria-hidden="true">#</a> 同步</h3><p>主从复制的第一步是执行同步操作，从节点对主节点的同步操作通过向主节点发送<code>SYNC</code>命令来完成，SYNC命令执行步骤如下：</p><ol><li>从节点向主节点发送<code>SYNC</code>命令</li><li>主节点收到SYNC命令后，执行<code>BGSAVE</code>命令，在后台生成RDB文件，并<strong>使用一个复制缓冲区（replicaiton buffer）记录从现在开始执行的所有写命令</strong></li><li>RDB文件生成后，主节点将RDB文件发送给从节点，从节点接收后，载入RDB文件</li><li>主节点将缓冲区的所有写命令发送给从节点，从节点执行这些命令，将自己的数据库状态更新至主节点当前状态</li></ol><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017112941480.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>[<strong>举例</strong>]一个具体的过程</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017135331618.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="命令传播" tabindex="-1"><a class="header-anchor" href="#命令传播" aria-hidden="true">#</a> 命令传播</h3><p>在同步操作执行完后，主从节点数据保持一致，但是这种一致状态并不是一成不变的，每当主节点执行写命令，主节点数据就有可能被修改，导致和从节点数据不一致</p><p>例如，在刚执行同步操作之后，主节点删除了一个kv，但是这个kv仍然在从节点上，此时主从节点就是数据不一致的</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017135831877.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了让主从节点继续保持一致，主节点需要进行命令传播操作，即主节点将写命令发送给从节点，然后从节点执行这个写命令，主从节点就回到了一致状态</p><h3 id="旧版复制存在的问题" tabindex="-1"><a class="header-anchor" href="#旧版复制存在的问题" aria-hidden="true">#</a> 旧版复制存在的问题</h3><p>首先，主从复制分为2种情况：</p><ul><li>初次复制：从节点第一次复制该主节点</li><li>断线后重复制：处于命令传播阶段的主从节点因为网络原因中断了复制，从节点自动重新连接主节点后，并继续复制主节点</li></ul><p>对于初次复制，旧版复制能很好的完成任务，但是<strong>对于断线后重复制，旧版复制功能效率太低了</strong></p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017141715763.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上图<code>T10093</code>可以看到，断线后重复制，需要同步的只是部分kv，但是却再次生成了全量数据的RDB文件，为了让从节点补足一小部分缺失的数据，却要让主节点重新执行一次SYNC命令，再次生成全量数据的RDB文件，这种做法效率很低</p><blockquote><p>补充介绍SYNC命令</p></blockquote><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017142318881.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="新版主从复制" tabindex="-1"><a class="header-anchor" href="#新版主从复制" aria-hidden="true">#</a> 新版主从复制</h2><p>为了解决旧版复制功能的问题，redis从2.8版本开始，使用<code>PSYNC</code>命令代替SYNC命令来执行复制时的同步操作</p><p><strong>PSYNC有完整重同步和部分重同步两种模式，也称为全量同步，增量同步</strong>：</p><ul><li>完整重同步：用于处理初次复制的情况，和SYNC执行步骤基本一致，都是通过主节点创建并发送RDB文件，以及向从节点发送保存在复制缓冲区（replication buffer）的写命令来进行同步</li><li>部分重同步：用于处理断线后的重复制情况，当断线重连时，如果满足条件，主节点会将断线期间执行的命令发送给从节点，从节点只需要接收并执行这部分命令，就能和主节点保持一致</li></ul><blockquote><p>在了解新版主从复制之前，需要先掌握几个概念</p></blockquote><h3 id="复制偏移量" tabindex="-1"><a class="header-anchor" href="#复制偏移量" aria-hidden="true">#</a> 复制偏移量</h3><p>主从节点分别维护一个复制偏移量offset：</p><ul><li>主节点每次向从节点传播N个字节的数据时，就将自己的offset+N</li><li>从节点每次收到数据，就将自己的offset+N</li></ul><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017155516613.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果主从节点处于一致状态，则offset值相等，如果不相等，offset值不同，上图中，A节点断线重连后，向主节点发送PSYNC命令进行同步，执行完整重同步还是部分重同步，跟复制积压缓冲区有关</p><h3 id="复制积压缓冲区" tabindex="-1"><a class="header-anchor" href="#复制积压缓冲区" aria-hidden="true">#</a> 复制积压缓冲区</h3><p>复制积压缓冲区（repl_backlog_buffer），是由主节点维护的一个<strong>固定长度</strong>的<strong>先进先出的队列</strong>，也被叫做环形缓冲区，默认大小为1MB，主节点上只有1个复制积压缓冲区</p><p>当主节点进行命令传播时，不仅会将写命令发送给从节点，还会将写命令写入到复制积压缓冲区</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017160418037.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当从节点断线重连，从节点通过PSYNC命令将自己的offset发送给主节点，主节点根据offset来决定执行何种同步：</p><ul><li>如果offset+1仍然在复制积压缓冲区中，因为时FIFO队列，说明offset后面的数据都能找得到，则主节点会执行部分重同步</li><li>如果offset+1不在复制积压缓冲区，说明最少有一条数据丢失了（即offset+1这条数据丢失了），因为是固定大小的队列，队列满了的话，队尾再来新的数据，队头的数据就需要出队了，则主节点会执行完整重同步</li></ul><h3 id="run-id" tabindex="-1"><a class="header-anchor" href="#run-id" aria-hidden="true">#</a> run ID</h3><p>每个redis节点，不管是主节点还是从节点，都有自己的run ID（运行 ID），run ID在服务启动时自动生成</p><ul><li>初次复制的时候，主节点会将自己的run ID发送给从节点</li><li>从节点断线重连到一个主节点时，会向其发送之前保存的run ID</li><li>如果与主节点run ID相同，说明这次重连的就是之前复制的主节点，可以继续执行部分重同步</li><li>如果与主节点run ID不同，说明这次重连的不是之前复制的主节点，只能执行完整重同步</li></ul><h3 id="新版主从复制步骤详解" tabindex="-1"><a class="header-anchor" href="#新版主从复制步骤详解" aria-hidden="true">#</a> 新版主从复制步骤详解</h3><blockquote><p>完整重同步，全量同步</p></blockquote><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017153739326.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>从节点发送<code>psync ? -1</code>，第一个参数是run ID，第初次同步不知道，于是传递？，第二个参数是offset，初次同步为-1</li><li>主节点收到命令，判断是全量同步，返回<code>fullresync runid offset</code> ，从节点会存储这两个值</li><li>主节点执行<code>bgsave</code>生成RDB文件，在生成过程中的写命令会存储到复制缓冲区<code>replication buffer</code></li><li>RDB文件生成后，主节点将其发送给从节点，从节点清空旧数据，加载RDB文件</li><li>加载完成后，主节点将复制缓冲区<code>replication buffer</code>中的写命令发送给从节点执行，达到主从一致</li></ul><p>待同步完毕，主从节点会保持一个长连接，主节点会通过这个连接将后续的写命令传递给从节点</p><blockquote><p>部分重同步，增量同步</p></blockquote><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017154119591.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017153530183.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当主从节点因为网络原因断开，然后重连的时候，如果条件满足，会进行部分重同步：</p><ul><li>从节点发送psync命令，如果run ID和主节点的相同，并且offset+1在复制积压缓冲区（repl_backlog_buffer）中，则可以进行部分重同步，向从节点响应<code>continue</code></li><li>主节点根据offset进行定位，将 <strong>复制积压缓冲区</strong> 中需要发送的写命令放入到 复<strong>制缓冲区</strong> ，再发送到从节点</li><li>从节点执行收到的写命令，达到主从一致</li></ul><h3 id="两个缓冲区的区别" tabindex="-1"><a class="header-anchor" href="#两个缓冲区的区别" aria-hidden="true">#</a> 两个缓冲区的区别</h3><ul><li><p>复制缓冲区：</p><ul><li>replicaiton buffer，因为不同从节点的同步速度不一样，<strong>主节点会为每个从节点创建一个复制缓冲区</strong>，用于记录生成RDB文件过程中主节点执行的写命令，实时传输写命令，可以理解为主要作用与全量同步</li><li>大小是动态的，因为对于同步速度较慢的从节点，需要更多的内存缓存数据</li><li>复制缓冲区的大小由<code>client-output-buffer-limit slave {hard limit} {soft limit} {soft seconds}</code>配置，默认值为client-output-buffer-limit slave 256MB 64MB 60，其含义是：如果buffer大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。</li></ul></li><li><p>复制积压缓冲区：repl_backlog_buffer，<strong>主节点只有一个复制积压缓冲区</strong>，用于增量同步，存储最近的写命令，同时还会存储该写命令对应的offset，默认大小为1MB。因为增量同步效率更高，所以可以适当增加其大小</p></li></ul><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241017172207490.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',59),o=[l];function g(s,n){return e(),a("div",null,o)}const f=i(r,[["render",g],["__file","主从复制原理.html.vue"]]);export{f as default};
