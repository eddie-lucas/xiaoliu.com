import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,e as o}from"./app-3d4993ca.js";const s="/assets/image-20231122105754329-1a30ec09.png",r="/assets/image-20231122110732874-d3cd9074.png",n="/assets/image-20231122111105351-51ecb83a.png",d="/assets/image-20231122142341517-d8478f7f.png",l="/assets/image-20231122182451336-470b9589.png",t="/assets/image-20231122190114576-f0d10b0c.png",c="/assets/image-20231122185847107-43de97b8.png",p="/assets/image-20231123095635083-394a0e6b.png",g="/assets/image-20231123100054512-175cd36c.png",f="/assets/image-20231123100946211-dc3a80d1.png",u="/assets/image-20231123104118114-191b5d02.png",b={},A=o('<h2 id="rdb持久化" tabindex="-1"><a class="header-anchor" href="#rdb持久化" aria-hidden="true">#</a> RDB持久化</h2><p>redis是内存数据库，如果断电或者服务器的redis进程退出，redis的数据就会消失，为了解决这个问题，redis提供了RDB持久化功能，可以将内存中的数据保存在磁盘中，避免数据意外丢失</p><p>RDB持久化既可以手动执行，也可以根据配置定期执行，该功能能够将某个时间点的数据库中的状态保存到RDB文件中去</p><p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，可以通过这个RDB文件来还原生成RDB文件时的数据库状态</p><p>RDB文件中保存的是某一时刻的全部数据，即RDB是一种全量快照，所以是一个比较重的操作，不可能频繁的执行</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="rdb文件的创建和载入" tabindex="-1"><a class="header-anchor" href="#rdb文件的创建和载入" aria-hidden="true">#</a> RDB文件的创建和载入</h3><blockquote><p>如何创建RDB文件？</p></blockquote><p><code>save</code>和<code>bgsave</code>命令可以用来生成RDB文件：</p><ul><li>save：阻塞主进程，直到RDB文件创建完成，在此期间，不处理任何请求，所有请求都会被阻塞</li><li>bgsave：创建子进程，由子进程区创建RDB文件，主进程能继续处理请求 <ul><li>bgsave命令执行期间，save/bgsave会被拒绝，防止同时调用<code>rdbSave()</code>，产生竞争条件</li><li><code>bgrewriteaof</code>和bgsave不能同时执行，如果bgsave在执行，bgrewriteaof会被延后；如果bgrewriteaof在执行，bgsave会被拒绝（这两个命令都由子进程执行，在操作方面没有什么冲突，由于这两个命令都要执行大量的磁盘写入操作，从性能方面考虑，让它们并发执行不是个好主意）</li></ul></li></ul><blockquote><p>如何载入RDB文件？</p></blockquote><p>redis启动的时候，RDB文件的载入操作会<strong>自动执行</strong>，<strong>载入期间，redis会被阻塞</strong>，载入成功后，控制台打印信息：</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因为AOF文件的更新频率更高，所以如果开启了AOF持久化，就会优先使用AOF文件来还原数据库状态，只有在AOF持久化关闭的时候，才会使用RDB</p><figure><img src="'+n+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="自动间隔性保存" tabindex="-1"><a class="header-anchor" href="#自动间隔性保存" aria-hidden="true">#</a> 自动间隔性保存</h3><p>由于bgsave不会阻塞主线程，所以redis允许用户配置save选项来每隔一段时间自动执行bgsave，默认会提供以下配置：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>save 900 1
save 300 10
save 60 10000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三个条件只要任意满足一个，就会执行bgsave：</p><ul><li><p>900秒内，对数据库至少进行了1次修改</p></li><li><p>300秒内，对数据库至少进行了10次修改</p></li><li><p>60秒内，对数据库至少进行了1000次修改</p></li></ul><h3 id="rdb文件的结构" tabindex="-1"><a class="header-anchor" href="#rdb文件的结构" aria-hidden="true">#</a> RDB文件的结构</h3><p>RDB文件由5部分组成：</p><ul><li>REDIS字符串：所有的RDB文件都是由一个内容为REDIS的字符串开头的，可以用来快速判断是否为RDB文件</li><li>db_version：RDB文件的版本号</li><li>databases：这部分包含0个或多个数据库，以及各个数据库的键值对的数据</li><li>EOF：结束标识，当redis读取RDB文件的时候，读取到这个标识，就说明所有的键值对都读取完毕</li><li>check_sum：校验和，由前面4部分计算得出，当载入RDB文件时，会计算前4部分的校验和与check_sum进行比较，从而校验RDB文件是否出错或者损坏</li></ul><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="aof持久化" tabindex="-1"><a class="header-anchor" href="#aof持久化" aria-hidden="true">#</a> AOF持久化</h2><p>AOF持久化通过保存redis所执行的写命令来记录数据库的状态，每执行一条写命令，就把该命令以追加的方式写入到aof文件中，重启redis的时候，通过重新执行文件中的写命令来恢复缓存的数据</p><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在 redis中 AOF 持久化功能默认是不开启的，需要我们修改 <code>redis.conf</code> 配置文件中的以下参数：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>appendonly		yes		//表示开启AOF持久化
appendfilename		appendonly.aof		//AOF持久化文件的名称
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>为什么redis先执行命令，再记录AOF日志？</p></blockquote><p>好处：</p><ol><li>避免额外检查开销：命令语法可能有错误，如果先记录日志，那么就需要对语法进行额外的检查，否则将错误的语句记到日志中，redis使用日志进行恢复的时候，可能会出错</li><li>不会阻塞当前的写命令：如果先写日志，日志没写完，则不执行写命令，写命令会被阻塞</li></ol><p>风险：</p><ol><li>执行写命令和记录日志是两个过程，如果redis还没来得及将命令写入到硬盘，就宕机了，那么数据就会有丢失的风险</li><li>可能会阻塞下一条命令：redis是单线程的，线程在写日志，虽然没有阻塞当前的写命令，但是对于下一条命令，由于日志还没有写完，下一条命令会被阻塞</li></ol><h3 id="aof的实现-硬盘写回策略" tabindex="-1"><a class="header-anchor" href="#aof的实现-硬盘写回策略" aria-hidden="true">#</a> AOF的实现（硬盘写回策略）</h3><p>AOF持久化的实现可以分为3个步骤：</p><ol><li>命令追加：redis执行完写命令之后，会将命令追加到<code>aof_buf</code>缓冲区</li><li>文件写入：通过调用<code>write()</code>系统调用，将缓冲区的数据写入到AOF文件中，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区<code>page cache</code>，等待内核将数据写入到硬盘</li><li>文件同步：将内核缓冲区的数据写入到硬盘</li></ol><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于上面的第3步，redis提供了<strong>3种硬盘写回策略</strong>，在 <code>redis.conf</code> 配置文件中的 <code>appendfsync</code> 配置项可以有以下 3 种参数：</p><ul><li><strong>Always</strong>，总是，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘</li><li><strong>Everysec</strong>，每秒，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘</li><li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘</li></ul><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这3种硬盘写回策略，只是在控制操作系统提供的<code>fsync()</code>方法的调用时机</p><ul><li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数</li><li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数</li><li>No 策略就是永不执行 fsync() 函数</li></ul><h3 id="aof重写-aof文件太大" tabindex="-1"><a class="header-anchor" href="#aof重写-aof文件太大" aria-hidden="true">#</a> AOF重写（AOF文件太大）</h3><p>AOF持久化通过保存写命令来记录数据库的状态，但是随着时间流逝，AOF文件会越来越大，如果不加以控制，会对服务器产生影响，并且AOF文件体积越大，使用它来还原数据库状态所需的时间也越久，为了解决AOF文件体积过大的问题，redis提供了AOF重写功能</p><p>AOF重写就是当AOF超过指定阈值，redis创建一个新的AOF文件来代替现有的AOF文件，新旧两个AOF文件保存的数据库状态完全相同，但是新AOF文件不会包含冗余命令，对于每个键值对，只保存一条写命令，也就是只保存键值对的最终状态，所以新AOF文件的体积要比旧的AOF文件小很多，重写工作完成后，新的AOF文件会覆盖旧的AOF文件</p><blockquote><p>重写时，为什么不直接复用原来的AOF文件？</p></blockquote><p>如果直接复用原来的AOF文件，如果重写失败了，AOF文件就会被污染，可能无法用于恢复，如果创建一个新的，即使重写失败，只用删除新的AOF文件，不会对现有的AOF文件产生影响</p><h3 id="aof后台重写" tabindex="-1"><a class="header-anchor" href="#aof后台重写" aria-hidden="true">#</a> AOF后台重写</h3><p>如果AOF重写的命令不多，对性能不会有什么太大的影响，如果重写的命令很多，那么这个过程时很耗时的，所以重写操作不能放到主进程中</p><p>redis的重写AOF的过程是由子进程<code>bgrewriteaof</code>来完成的，这样有两个好处：</p><ul><li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程</li><li><strong>子进程带有主进程的数据副本</strong>，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生<code>写时复制（copy on write）</code>，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全</li></ul><blockquote><p>子进程如何拥有数据副本？</p></blockquote><p>主进程在通过 <code>fork</code> 系统调用生成子进程时，操作系统会把主进程的<strong>页表</strong>复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者虚拟空间不同，但其对应的物理空间是同一个</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够<strong>节约物理内存资源</strong>，页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong></p><p>不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>，这个写保护中断是由于违反权限导致的，然后操作系统会在<code>写保护中断处理函数</code>里进行<strong>物理内存的复制</strong>，并重新设置其内存映射关系，将父子进程的内存读写权限设置为<strong>可读写</strong>，最后才会对内存进行写操作，这个过程被称为<strong>写时复制(Copy On Write)</strong>。</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上述过程中，有两个阶段会导致阻塞父进程：</p><ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，<strong>页表越大，阻塞的时间也越长</strong></li><li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果<strong>需要拷贝的内存越大，自然阻塞的时间也越长</strong></li></ul><p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p><p>但是子进程重写过程中，主进程依然可以正常处理命令。</p><p>如果此时<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的</strong>。</p><p>所以如果这个阶段修改的是一个 bigkey，也就是数据量比较大的 key-value 的时候，这时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。</p><blockquote><p>重写 AOF 日志过程中，主进程修改了已经存在 key-value，2个进程内存数据不一致，怎么办？</p></blockquote><p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p><p>在重写 AOF 期间，当 Redis 执行完一个写命令后，它会<strong>同时将这个写命令写入到 <code>AOF缓冲区</code>和 <code>AOF重写缓冲区</code></strong></p><figure><img src="'+f+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p><ul><li>执行客户端发来的命令</li><li>将执行后的写命令追加到AOF 缓冲区</li><li>将执行后的写命令追加到AOF 重写缓冲区</li></ul><p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p><p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p><ul><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致</li><li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件</li></ul><p>信号函数执行完后，主进程就可以继续像往常一样处理命令了（<strong>这个过程也会对主进程造成阻塞</strong>）</p><p>在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程</p><h3 id="补充-bgsave期间-修改数据" tabindex="-1"><a class="header-anchor" href="#补充-bgsave期间-修改数据" aria-hidden="true">#</a> 补充：bgsave期间，修改数据</h3><p>由于上面的写时复制技术，bgsave期间，主进程是可以修改数据的，bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照，因为写时复制，只会复制修改的部分</p><p>所以 Redis 在使用 bgsave 快照过程中，如果主线程修改了内存数据，不管是否是共享的内存数据，RDB 快照都无法写入主线程刚修改的数据，因为此时主进程的内存数据和子进程的内存数据已经分离了，子进程写入到 RDB 文件的内存数据只能是原本的内存数据。</p><p>如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p><p>另外，写时复制的时候会出现这么个极端的情况。</p><p>在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份。</p><p>那么极端情况下，<strong>如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍</strong></p><h2 id="rdb-aof混合持久化" tabindex="-1"><a class="header-anchor" href="#rdb-aof混合持久化" aria-hidden="true">#</a> RDB+AOF混合持久化</h2><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><ul><li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失</li><li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销</li></ul><p>RDB+AOF混合持久化既有RDB恢复数据快的特点，又有AOF数据丢失少的特点</p><p>开启混合持久化：</p><div class="language-conf line-numbers-mode" data-ext="conf"><pre class="language-conf"><code>aof-use-rdb-preamble yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时：</p><ol><li><code>fork</code> 出来的重写子进程会先将与主进程<strong>共享的内存数据以 RDB 方式写入到 AOF 文件</strong></li><li>主线程在此期间处理的操作命令会被记录在<code>重写缓冲区</code>里，<strong>重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件</strong>，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件</li></ol><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong></p><figure><img src="`+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',93),O=[A];function F(h,m){return i(),a("div",null,O)}const _=e(b,[["render",F],["__file","AOF和RDB持久化.html.vue"]]);export{_ as default};
