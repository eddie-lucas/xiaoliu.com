import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as i,e as o}from"./app-3d4993ca.js";const t="/assets/阻塞IO模型图-f912f2ca.png",r="/assets/非阻塞IO模型图-1705390706659-aae91181.png",c="/assets/IO复用模型图-1705386324564-402104ae.png",n="/assets/信号驱动IO模型图-8a1b59e9.png",s="/assets/异步IO模型图-80d60038.png",d={},l=o('<h2 id="阻塞io模型" tabindex="-1"><a class="header-anchor" href="#阻塞io模型" aria-hidden="true">#</a> 阻塞IO模型</h2><p>这是最常用的IO模型， 默认情况下，所有文件操作都是阻塞的，在socket中，当在进程空间调用<code>recvfrom</code>，其系统调用直到数据包被复制到应用程序的缓冲区中或者发生错误才会返回，在此期间会一直等待，进程从调用<code>recvfrom</code>开始到它返回的整段时间都是阻塞的，因此被称为阻塞IO模型</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="非阻塞io模型" tabindex="-1"><a class="header-anchor" href="#非阻塞io模型" aria-hidden="true">#</a> 非阻塞IO模型</h2><p>进程调用<code>recvfrom</code>轮询内核，如果没有数据准备好，就返回一个<code>EWOULDBLOCK</code>错误，直到数据准备好，才能够处理数据</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="io复用模型" tabindex="-1"><a class="header-anchor" href="#io复用模型" aria-hidden="true">#</a> IO复用模型</h2><p>Linux提供了select/poll，进程通过将一个或多个fd（文件描述符）传递给select/poll系统调用，阻塞在select操作上，这样，select/poll就可以检测多个fd是否处于就绪状态，<strong>select/poll顺序扫描fd是否就绪，而且支持的fd数量是有限的</strong>，Linux还提供了一个epoll系统调用，epoll基于事件驱动方式替代顺序扫描，性能更高，当有fd就绪，立即执行回调函数rollback</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="信号驱动io模型" tabindex="-1"><a class="header-anchor" href="#信号驱动io模型" aria-hidden="true">#</a> 信号驱动IO模型</h2><p>首先开启信号驱动IO功能，并通过系统调用sigaction执行一个信号处理函数（非阻塞的），当数据准备就绪时，就向该进程发送一个SIGIO信号，通过信号通知进程调用recvfrom来读取数据</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="异步io模型" tabindex="-1"><a class="header-anchor" href="#异步io模型" aria-hidden="true">#</a> 异步IO模型</h2><p>告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户空间的缓冲区）进行通知，这种模型与信号驱动IO模型的区别：<strong>信号模型由内核通知我们何时可以开始一个IO操作；异步IO模型由内核通知我们IO操作何时已完成</strong></p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',15),f=[l];function p(g,h){return a(),i("div",null,f)}const u=e(d,[["render",p],["__file","5种IO模型.html.vue"]]);export{u as default};
