import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,e as t}from"./app-3d4993ca.js";const r="/assets/image-20240117170042532-a76c0301.png",l={},c=t('<h2 id="tcp粘包-拆包" tabindex="-1"><a class="header-anchor" href="#tcp粘包-拆包" aria-hidden="true">#</a> TCP粘包/拆包</h2><p>TCP是一个“流协议”，所谓流就是一串没有界限的数据，就像河里的水，是连成一片的，没有分界线，TCP底层并不了解上层业务数据的具体含义，会根据TCP缓冲区的实际情况进行包的划分，所以，<strong>一个完整的包可能会被TCP拆成多个包进行发送，也有可能把多个小的包封装成一个大的数据包进行发送</strong>，这就是TCP粘包和拆包</p><h2 id="粘包-拆包发生的原因" tabindex="-1"><a class="header-anchor" href="#粘包-拆包发生的原因" aria-hidden="true">#</a> 粘包/拆包发生的原因</h2><ul><li>应用程序write写入的字节的大小&gt;套接字发送缓冲区大小</li><li>进行MSS大小的TCP分段</li><li>进行MTU大小的IP分片</li></ul><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="粘包问题解决策略" tabindex="-1"><a class="header-anchor" href="#粘包问题解决策略" aria-hidden="true">#</a> 粘包问题解决策略</h2><p>由于TCP无法理解上层的数据，所以在底层无法保证数据包不被拆分和重组，只能通过上层来解决，主流方案如下：</p><ol><li>消息定长。例如每个报文固定长度为200字节，如果不够，空位补空格</li><li>在包尾增加回车换行符进行分割。例如FTP</li><li>将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段</li></ol>',8),n=[c];function o(s,d){return i(),a("div",null,n)}const f=e(l,[["render",o],["__file","粘包拆包问题.html.vue"]]);export{f as default};
