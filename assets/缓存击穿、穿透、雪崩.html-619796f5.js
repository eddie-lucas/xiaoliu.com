import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as p,e as l}from"./app-3d4993ca.js";const o="/assets/image-20231127100540461-d2d347b8.png",t={},a=l('<h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h2><p>缓存击穿：热点数据失效，导致大量请求直接访问数据库，造成数据库压力过大</p><p>解决方案：</p><ul><li>热点数据不设置过期时间</li><li>加互斥锁，当热点数据过期的时候，只让获得锁的线程去访问数据库然后设置缓存</li></ul><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h2><p>缓存穿透：攻击者故意大量请求一些redis和数据库中不存在的数据</p><p>解决方案：</p><ul><li><p>做好请求校验，api入口处，要判断请求参数是否合理，请求参数是否含有非法值等，无效请求直接返回，避免访问缓存和数据库</p></li><li><p>缓存空值或默认值，对于缓存和数据库都找不到的数据，可以在redis中缓存空值或者默认值，为了避免redis中缓存大量无效的数据，可以设置一个很短的过期时间，比如1分钟</p></li><li><p>布隆过滤器，在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的</p></li></ul><blockquote><p>布隆过滤器（bitmap）工作原理</p></blockquote><p>布隆过滤器由<code>初始值都为 0 的位图数组</code>和<code>N 个哈希函数</code>两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h2><p>缓存雪崩：大量key集体过期</p><p>解决方案：</p><ul><li><p>均匀设置过期时间，在设置过期时间的时候，加上一个随机值，避免key集体失效</p></li><li><p>互斥锁，当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p></li><li><p>双key策略，我们对缓存数据可以使用两个 key，一个是主 key，会设置过期时间，一个是备 key，不会设置过期，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p><p>当业务线程访问不到<code>主 key </code>的缓存数据时，就直接返回<code>备 key </code>的缓存数据，然后在更新缓存的时候，同时更新主 key 和备 key 的数据。</p></li></ul>',21),r=[a];function s(d,n){return i(),p("div",null,r)}const h=e(t,[["render",s],["__file","缓存击穿、穿透、雪崩.html.vue"]]);export{h as default};
