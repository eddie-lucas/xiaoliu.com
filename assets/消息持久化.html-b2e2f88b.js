import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,e as o}from"./app-3d4993ca.js";const r="/assets/image-20231215151421249-0793a100.png",t={},l=o('<h2 id="消息发送的流程" tabindex="-1"><a class="header-anchor" href="#消息发送的流程" aria-hidden="true">#</a> 消息发送的流程</h2><ol><li>生产者发送消息给MQ</li><li>MQ收到消息，将<strong>消息持久化存储</strong></li><li>返回ack给生产者</li><li>MQ发送消息给消费者</li><li>如果消费者成功消费，则删除掉持久化的消息</li></ol><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="接收消息的入口" tabindex="-1"><a class="header-anchor" href="#接收消息的入口" aria-hidden="true">#</a> 接收消息的入口</h2><p>BrokerController#start</p><p>this.remotingServer#start-&gt;prepareSharableHandlers</p><p>serverHandler = new NettyServerHandler()</p><p>processMessageReceived-&gt;processRequestCommand</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240622165814807.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>经过层层定位，终于找到了broker接收消息的入口</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240622170406467.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于producer发送过来的消息，会将接收到的消息封装到<strong>MessageExtBrokerInner</strong>，然后会将其写入到<code>commitlog</code></p><h2 id="commitlog与刷盘" tabindex="-1"><a class="header-anchor" href="#commitlog与刷盘" aria-hidden="true">#</a> commitlog与刷盘</h2><p>通过查看源码，发现消息会被写到commitlog中，commitlog具有以下特点：</p><ul><li>顺序写入</li><li>消息只要被写入到commitlog，就不会丢失</li><li>每个commitlog文件默认大小为1G</li><li>文件以commitlog的起始偏移量命名</li></ul><h2 id="存储方式" tabindex="-1"><a class="header-anchor" href="#存储方式" aria-hidden="true">#</a> 存储方式</h2><p><strong>MQ采用的是文件系统</strong>来进行存储的，磁盘如果使用得当，磁盘的速度完全可以匹配上网络的数据的传输速度，目前高性能的磁盘，顺序写的速度能达到600MB/s，超过了一般网卡的传输速度，但是磁盘的随机写只有大概100KB/s，和顺序写速度相差很大，RocketMQ采用顺序写，来保证消息的存储速度</p><blockquote><p>零拷贝技术</p></blockquote><p>操作系统分为<code>用户态</code>和<code>内核态</code>，文件操作，网络操作涉及到两种状态的切换，数据也在两种状态之间来回拷贝</p><p>传统IO中，一台服务器将本机的文件通过网络发送出去，通常需要两个步骤：</p><ol><li>read读取本地文件</li><li>write将内容通过网络发送出去</li></ol><p>看似简单的2个步骤，其实包含了4次拷贝：</p><ol><li>磁盘拷贝到内核态</li><li>内核态拷贝到用户态</li><li>用户态进行了一些操作之后，又拷贝到内核态</li><li>内核态拷贝到网卡进行发送</li></ol>',23),c=[l];function s(n,d){return i(),a("div",null,c)}const m=e(t,[["render",s],["__file","消息持久化.html.vue"]]);export{m as default};
