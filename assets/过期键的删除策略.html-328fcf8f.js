import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e}from"./app-3d4993ca.js";const p="/assets/image-20231121155036144-33243d86.png",t="/assets/image-20231122091707690-fa0f9384.png",o={},i=e(`<h2 id="可能的过期键删除策略" tabindex="-1"><a class="header-anchor" href="#可能的过期键删除策略" aria-hidden="true">#</a> 可能的过期键删除策略</h2><p>redis的过期键是放在过期字典中的，如果要判定一个键过期，需要经过以下步骤：</p><ol><li>检查给定的键是否存在于过期字典中，如果存在，那么取得键的过期时间</li><li>检查当前时间是否大于键的过期时间，如果是，则键已过期，否则键未过期</li></ol><p>知道了如何去判断键是否过期，那么键过期后，什么时候会被删除呢？</p><p>可能的删除策略有三种，<strong>redis中使用的是后面2种相结合</strong>：</p><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时删除键</li><li><strong>惰性删除</strong>：放任键过期不管，但是每次获取键的时候，都会检查键是否过期，过期则删除</li><li><strong>定期删除</strong>：每隔一段时间对数据库进行一次检查，删除过期键，至于删除多少过期键，以及要检查多少个数据库，由算法决定</li></ul><h3 id="定时删除" tabindex="-1"><a class="header-anchor" href="#定时删除" aria-hidden="true">#</a> 定时删除</h3><p>定时删除策略对内存是友好的，通过定时器，让过期的键能够尽快的删除，从而释放内存空间</p><p>但是它对CPU是不友好的，在过期键比较多时，删除过期键这一行为可能会占用很多CPU时间，如果CPU时间非常紧张，但是却把CPU时间浪费在删除和当前任务无关的过期键上，会影响服务器的响应时间和吞吐量</p><p>除此之外，创建定时器需要用到redis的时间事件，时间事件的实现方式是无序链表，查找时间复杂度为O(N)，并不高效</p><h3 id="惰性删除" tabindex="-1"><a class="header-anchor" href="#惰性删除" aria-hidden="true">#</a> 惰性删除</h3><p>惰性删除对CPU是友好的，程序只有在取出键的时候才会对键进行过期检查，这可以保证删除过期键的操作只在非做不可的情况下进行，并且删除的目标只为当前键，不会为其他过期键浪费CPU时间</p><p>但是他对内存是不友好的，键过期了并没有删除，而是仍然占据着内存空间</p><h3 id="定期删除" tabindex="-1"><a class="header-anchor" href="#定期删除" aria-hidden="true">#</a> 定期删除</h3><p>定期删除是前面两种策略的整合和折中</p><p>定期删除，<strong>每隔一段时间随机从数据库中取出一定数量的设置了过期时间的key进行检查，并删除其中的过期key</strong>，并且通过限制删除操作执行的时长和频率来减少对CPU时间的影响</p><p>另外，通过定期删除过期key，定期删除策略有效的减少了过期key对内存的占用</p><p>但是如何确定删除操作的执行时间和频率是定期删除的难点</p><h2 id="redis的过期删除策略" tabindex="-1"><a class="header-anchor" href="#redis的过期删除策略" aria-hidden="true">#</a> Redis的过期删除策略</h2><p>redis采用<strong>惰性删除+定期删除配合使用</strong></p><h3 id="redis怎么实现惰性删除" tabindex="-1"><a class="header-anchor" href="#redis怎么实现惰性删除" aria-hidden="true">#</a> redis怎么实现惰性删除？</h3><p>redis的惰性删除由db.c种的<code>expireIfNeeded</code>函数实现：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">expireIfNeeded</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断 key 是否过期</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">keyIsExpired</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">/* 删除过期键 */</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；</span>
    <span class="token keyword">return</span> server<span class="token punctuation">.</span>lazyfree_lazy_expire <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token function">dbAsyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">dbSyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>redis在访问key的时候都会调用<code>expireIfNeeded</code>函数检查key是否过期，如果没有过期则返回value的值，如果过期了，则删除过期键，采用同步删除还是异步删除由参数<code>server.lazyfree_lazy_expire</code>控制</p><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="redis怎么实现定期删除" tabindex="-1"><a class="header-anchor" href="#redis怎么实现定期删除" aria-hidden="true">#</a> Redis怎么实现定期删除？</h3><p>上面说到，定期删除是每隔一段时间随机抽查一些key，然后删除其中的过期key</p><blockquote><p>间隔时间是多久？</p></blockquote><p>在redis中，默认<strong>每秒进行10次抽查</strong>，可以配置redis.conf中的hz属性进行修改，hz默认值为10</p><blockquote><p>随机抽查的key的数量是多少？</p></blockquote><p>每次抽查会<strong>随机抽取20个key进行检查</strong>，随机抽查的数量是被写死在<code>activeExpireCycle</code> 函数中</p><p>redis定期删除流程：</p><ol><li>从过期字典中随机抽取20个key</li><li>检查这20个key是否过期，并且删除已过期的key</li><li>如果本轮检查，过期key的数量超过5个，也就是<strong>占比大于25%，继续重复步骤1</strong>；如果占比小于25%，则停止删除过期key，等待下一轮抽查</li></ol><p>定期删除是一个循环的流程，但是不会一直循环下去，不然会导致线程卡死，有一个执行时间上限，默认不会超过<code>25ms</code></p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',35),c=[i];function r(l,d){return s(),a("div",null,c)}const h=n(o,[["render",r],["__file","过期键的删除策略.html.vue"]]);export{h as default};
