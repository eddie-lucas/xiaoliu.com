import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e as t}from"./app-3d4993ca.js";const p="/assets/image-20240118142615670-78e20fe7.png",e="/assets/image-20240118142652461-efd5741c.png",o="/assets/image-20240118143215758-14dc0d23.png",c="/assets/image-20240118143845003-3715f522.png",l={},i=t('<h2 id="reactor线程模型" tabindex="-1"><a class="header-anchor" href="#reactor线程模型" aria-hidden="true">#</a> Reactor线程模型</h2><p>Netty的线程模型，是从Reactor的基础线程模型演变过来的，先了解一下Reactor线程模型</p><h3 id="reactor单线程模型" tabindex="-1"><a class="header-anchor" href="#reactor单线程模型" aria-hidden="true">#</a> Reactor单线程模型</h3><p>Reactor<strong>单线程模型，是指所有的IO操作都在同一个NIO线程完成</strong>，NIO线程职责如下：</p><ol><li>作为NIO服务端，接收客户端的TCP连接</li><li>作为NIO客户端，向服务端发起TCP连接</li><li>读取通信对端的请求或应答信息</li><li>向通信对端发送消息请求或者应答消息</li></ol><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在一些小容量的应用场景下，可以使用单线程模型，但是这对于高负载、大并发的应用场景却不合适，因为：</p><ol><li>一个NIO线程同时处理成百上千的连接，性能上无法支撑</li><li>当NIO线程负载过重后，处理速度会变慢，这就会导致大量客户端连接超时，超时之后往往会重发，这更加重了NIO线程的负载，最终导致大量消息积压和处理超时，成为系统的性能瓶颈</li><li>一旦NIO线程意外关闭，会导致整个系统的通信模块不可用</li></ol><h3 id="reactor多线程模型" tabindex="-1"><a class="header-anchor" href="#reactor多线程模型" aria-hidden="true">#</a> Reactor多线程模型</h3><p>Reactor多线程模型与单线程最大的区别就是有一组NIO线程来处理IO操作，其特点如下：</p><ol><li>有一个专门的NIO线程用于接收客户端的TCP连接请求</li><li>网络IO操作由一个NIO线程池负责，线程池中的线程负责消息的读取，解码，编码，发送</li></ol><figure><img src="'+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在绝大多数场景下，该模型能够满足性能需求，但是个别特殊场景下，可能会存在性能问题，例如：并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，认证是非常损耗性能的，此时，该模型可能就不适用</p><h3 id="主从reactor多线程模型" tabindex="-1"><a class="header-anchor" href="#主从reactor多线程模型" aria-hidden="true">#</a> 主从Reactor多线程模型</h3><p>在该模型中，服务端用于接收客户端连接的不再是一个单独的NIO线程，而是一个NIO线程池，Acceptor线程池仅仅用于客户端的登录、握手和安全认证，一旦连接建立成功，就将其交由后续的NIO线程池的IO线程，由IO线程负责后续的IO操作</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="netty的线程模型" tabindex="-1"><a class="header-anchor" href="#netty的线程模型" aria-hidden="true">#</a> Netty的线程模型</h2><p>Netty的线程模型并不是一成不变的，取决于参数配置，通过设置不同的参数，可以采用不同的Reactor模型，下面是Netty的线程模型</p><figure><img src="'+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以通过服务端启动代码来具体了解：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">EventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">EventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span><span class="token constant">SO_BACKLOG</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span><span class="token constant">INFO</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> socketChannel<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
                <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span><span class="token constant">INFO</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ChannelFuture</span> channelFuture <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">18080</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    channelFuture<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端启动的时候创建了两个<code>NioEventLoopGroup</code>，它们是两个独立的线程池，一个用于接收客户端的TCP连接，另一个用于处理IO相关的读写操作，或者执行系统任务，定时任务等</p><p>bossGroup线程池（接收请求）职责如下：</p><ol><li>接收客户端TCP连接，初始化Channel参数</li><li>将链路状态变更事件通知给ChannelPipeline</li></ol><p>workerGroup线程池职责如下：</p><ol><li>异步读取通信对端的数据报，发送读事件到ChannelPipeline</li><li>异步发送消息到通信对端，调用ChannelPipeline的消息发送接口</li><li>执行系统调用任务</li><li>执行定时任务，例如链路空闲状态检测定时任务</li></ol>`,26),u=[i];function r(k,d){return s(),a("div",null,u)}const h=n(l,[["render",r],["__file","Netty的线程模型.html.vue"]]);export{h as default};
