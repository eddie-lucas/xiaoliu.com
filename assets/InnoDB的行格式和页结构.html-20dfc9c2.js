import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as a,e as r}from"./app-3d4993ca.js";const n="/assets/image-0d0c8453.png",o="/assets/image-20231118155607114-22f36dfe.png",t="/assets/image-20231118160055055-9721bf74.png",s="/assets/image-1700283722588-f08a367e.png",l="/assets/image-20231118154913046-d94a3d1f.png",g="/assets/image-20231118155105989-375933b9.png",d="/assets/image-20231118161205925-b0dac12b.png",p="/assets/image-20231118163555795-75cb38db.png",c="/assets/image-20231118164322206-fd87b043.png",f="/assets/image-20231118165803923-ac5f5215.png",h={},u=r('<h2 id="innodb行格式" tabindex="-1"><a class="header-anchor" href="#innodb行格式" aria-hidden="true">#</a> InnoDB行格式</h2><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘存放的方式也被称为<strong>行格式</strong>，InnoDB目前有4种行格式，分别是<strong>Compact</strong>，<strong>Redundant</strong>，<strong>Dynamic</strong>，<strong>Compressed</strong></p><ol><li>Compact行格式</li></ol><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>变长字段长度列表：<strong>逆序存放</strong>变长字段真实长度</p></li><li><p>NULL值列表：<strong>逆序存放</strong>，1表示null，0表示不为null，长度为字节的整数倍，不够则高位补0</p></li><li><p>记录头信息：</p></li></ul><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>另外，每一行是有三个隐藏字段的：隐藏主键，最近修改事务id，回滚指针，所以，一行记录的完整的样子如下：</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><ol start="2"><li>Redundant行格式</li></ol><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>字段长度偏移列表：<strong>逆序存放</strong>所有列的长度信息（以偏移量的形式），通过<strong>两两做差求出真实长度</strong><ul><li>偏移量的二进制数的第一个比特位表示是否为null、</li></ul></li></ul><h3 id="为什么都要逆序存放" tabindex="-1"><a class="header-anchor" href="#为什么都要逆序存放" aria-hidden="true">#</a> 为什么都要逆序存放？</h3><p>从上面的记录头信息图中可以看出，一条记录的记录头信息中有一个<strong>指向下一条记录的指针</strong>，这个指针指向的位置是下一条记录的额外信息和真实数据之间的位置，这样的好处是，<strong>向左读取的字段的信息的顺序跟向右读取的字段的真实数据的顺序相同</strong></p><h3 id="被删除的记录如何处理" tabindex="-1"><a class="header-anchor" href="#被删除的记录如何处理" aria-hidden="true">#</a> 被删除的记录如何处理？</h3><p>从上面的记录头信息中看到，有一个属性代表记录是否被删除，当我们delete一条记录的时候，其实只是修改了这个标志位，并没有被真正删除，这些记录之所以不立即从磁盘上删除，是因为在删除之后，其他记录在磁盘上需要重新排列，这对性能有消耗，所以只是打上标记，然后将被删除的记录串成一个垃圾链表，垃圾链表中的记录占用的空间称为可重用空间，之后插入新的记录是，可以覆盖这些空间</p><p>MySQL是由延迟清理机制的，也就是并不第一时间删除垃圾记录，而是延迟一段时间才清理</p><p><strong>延迟清理的优点</strong>：</p><ol><li>延迟清理能够提高数据库性能，避免了大量的IO操作</li><li>减少了磁盘碎片，立即删除时会产生大量碎片，延迟清理能够减少磁盘碎片，并提高读写效率</li></ol><p><strong>延迟清理的缺点</strong>：</p><ol><li>占用磁盘空间，不删除数据而只是标记，数据仍然存在于磁盘中，垃圾数据占用了磁盘空间，可以定期清理已删除的数据：使用<code>OPTIMIZE TABLE</code>，会重新排列表，删除已删除的数据</li></ol><h3 id="行溢出" tabindex="-1"><a class="header-anchor" href="#行溢出" aria-hidden="true">#</a> 行溢出</h3><p>MySQL中数据存在磁盘中，而真正处理数据的过程是在内存中，所以需要把磁盘中的数据加载到内存中，磁盘读写的速度和内存相比，差距很大，所以我们获取记录时不是一条条的从磁盘读取记录，而是以页作为磁盘和内存交互的基本单位，一页中有很多条记录，InnoDB中页的大小一般为16KB</p><p><strong>行溢出</strong>：MySQL中一页16k，而varchar最大容量约为64k，当数据很大，装不下时，就会发生行溢出</p><p>对于Compact和Redundant行格式，发生行溢出时，<strong>列存放的是部分数据+指向其他页的指针</strong>，将溢出的数据存放在其他页</p><p>Dynamic和Compressed行格式和Compact基本相同，行溢出时，它们的<strong>列存放指向其他页的指针</strong>，不存放数据</p><p>Compressed行格式相比于Dynamic，Compressed采用了压缩算法对页面进行压缩，更节省空间</p><h2 id="innodb索引页结构" tabindex="-1"><a class="header-anchor" href="#innodb索引页结构" aria-hidden="true">#</a> InnoDB索引页结构</h2><p>InnoDB为了不同的目的而设计了许多不同类型的页，比如存放undolog的undo页，存放数据的索引页，也可以叫做数据页</p><p>MySQL中，一页16k，这16k的索引页被划分为多个部分，不同部分有不同的功能</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从图中可以看出，索引页被划分为了7个部分</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>刚开始生成页的时候，其实并没有<code>user records</code>这部分，当我们插入数据的术后，会从free space划分出一块到user records部分，当free space空间全部被替换掉之后，就说明这一页用完了，需要去申请新的页</p><h3 id="file-header-file-trailer" tabindex="-1"><a class="header-anchor" href="#file-header-file-trailer" aria-hidden="true">#</a> File Header+File Trailer</h3><p>MySQL有很多类型的页，File Header和File Trailer中记录的是各种类型的页都通用的信息，不同类型的页都会以File Header作为第一个组成部分，File Trailer作为最后一个部分，下图是File Header中记录的内容</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>什么是校验和？校验和有什么用处？</p></blockquote><ul><li>什么是校验和？</li></ul><p>简单来说，<strong>页的校验和就代表这个页</strong>。举个例子，比如一个很长的字符串，现在通过某种算法，计算出一个比较短的值，这就是它的<strong>校验和</strong>，校验和能够代表这个很长的字符串，当需要与另一个很长的字符串比较是否相等时，只用比较两个字符串的校验和就可以了，这样效率更高</p><ul><li>校验和有什么用处？</li></ul><p>我们知道InnoDB是把数据存储到磁盘上的，但是磁盘内存速度差距太大，需要以页为单位进行交互，如果内存中的页被修改，会被标记为脏页，在之后的某个时间会将数据同步到磁盘中，如果在同步到一半的时候断电了，因此<strong>校验和用来检测一个页是否完整</strong></p><ul><li>校验和是如何工作的？</li></ul><p>File Header和File Trailer中都有校验和，每当一个页面在内存中修改了，在同步到磁盘之前，要把它的校验和算出来，因为File Header在页面的前面，所以校验和会被首先同步到磁盘，当页完全同步成功时，校验和也会被写在File Trailer中，这样，文件头和文件尾的校验和就是一致的；如果写了一半发生了断电，那么文件头和文件尾的校验和是不一致的，文件头中的校验和代表已经修改过的页面，而文件尾中的校验和代表原来的页面，二者不一致，代表同步中出现了错误</p><h3 id="page-header" tabindex="-1"><a class="header-anchor" href="#page-header" aria-hidden="true">#</a> Page Header</h3><p>Page Header是专门针对索引页的，用来记录索引页中存储的记录的状态信息</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="最大-最小记录" tabindex="-1"><a class="header-anchor" href="#最大-最小记录" aria-hidden="true">#</a> 最大+最小记录</h3><p>每个索引页都会被自动加上最大，最小两条记录，这两条记录并不是我们自己插入的数据，最大+最小记录是两个虚拟记录，MySQL中记录与记录之间形成一个链表，<strong>最小记录的下一条记录是本页中主键值最小的记录，本页中那个主键值最大的记录的下一条记录是最大记录</strong></p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="page-directory" tabindex="-1"><a class="header-anchor" href="#page-directory" aria-hidden="true">#</a> Page Directory</h3><p>由上图可知，记录在页中按照主键值由小到大的顺序链接成了一个单链表，如果想根据主键查找记录的时候应该则怎么办？</p><p>最简单的方法：遍历链表，这种方法显然是不可取的，当数据多的时候，遍历链表要花费大量的时间</p><p>平常看书的时候，先看目录，然后根据目录找到对应的内容，<strong>Page Directory（页目录）就相当于记录的目录</strong></p><p>Page Directory的生成过程如下：</p><ol><li>将所有正常的记录（包括最大、最小记录，不包括标记为已删除的记录）划分为几个组</li><li>每个组的最后一条记录（组内主键最大的记录）的头信息中的<code>n_owned</code>表示该组内共有几条记录</li><li>将每个组的最后一条记录的地址偏移量提取出来，按照顺序存储到页目录中，页目录中的这些地址偏移量称为<code>槽</code></li></ol><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>InnoDB规定：</p><ul><li>最小记录所在分组只能有一条记录</li><li>最大记录所在分组中的记录条数在1-8条之间</li><li>其他分组中的记录条数在4-8条之间</li></ul><p>在一个索引页中查找指定主键值的记录的过程分为两步：</p><ol><li>二分法确定该记录所在的槽，即找到该记录所在的分组，并找到该槽中主键最小的记录</li><li>通过记录的<code>next_record</code>遍历该组记录，最后找到目标记录</li></ol>',61),m=[u];function _(b,y){return e(),a("div",null,m)}const B=i(h,[["render",_],["__file","InnoDB的行格式和页结构.html.vue"]]);export{B as default};
