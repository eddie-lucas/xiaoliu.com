import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as t,e as s}from"./app-3d4993ca.js";const i={},p=s(`<h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h2><h3 id="sds" tabindex="-1"><a class="header-anchor" href="#sds" aria-hidden="true">#</a> SDS</h3><p>redis中字符串的默认实现是SDS（简单动态字符串），相比于C语言中传统的字符串类型更加强大</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240828084950469.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>相比于C语言的传统字符串，SDS的强大之处主要体现在：</p><blockquote><p>常数时间复杂度获取字符串长度</p></blockquote><p>因为C语言的字符串并不记录自身的长度，因此当需要获取长度的时候，必须要遍历整个字符串，而SDS使用len来记录字符串的长度，可以直接获取</p><blockquote><p>避免缓冲区溢出</p></blockquote><p>比如当进行字符串拼接的时候，C语言的拼接函数默认已经分配了足够的内存空间，如果拼接之前忘记分配足够的空间了，就会造成数据溢出，而SDS的拼接函数会先检查空间是否足够，如果不够的话，会先扩容，然后再执行拼接操作</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240828090803191.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>减少修改字符串时的内存重分配次数</p></blockquote><p>传统实现，在修改字符串的时候，比如拼接/截断，在C语言中会通过内存重分配来扩展/释放空间，内存重分配涉及复杂的算法，并且需要执行系统调用，是一个比较耗时的操作</p><p>但是redis对于性能有着严苛要求，所以SDS通过<strong>free字段+空间预分配+惰性空间释放策略</strong>来弥补了传统实现的缺点</p><p>空间预分配策略用于字符串增长操作，当SDS因字符串变长，并且需要扩容的时候，不仅会分配必须的内存空间，并且会额外多分配一些空间，在后续执行字符串增长操作的时候就能够使用这些额外分配的空间，从而减少内存重分配次数</p><p>惰性空间释放策略用于字符串缩短操作，当SDS缩短，并不会立即通过内存重分配来回收内存空间，而是使用free字段记录，并等待将来使用，这样，之后要用的时候，如果空间够，也不用进行内存重分配了</p><blockquote><p>二进制安全</p></blockquote><p>传统实现的字符串只能保存文本数据，而不能保存图片，音频，视频这样的二进制数据，SDS的api都是二进制安全的，SDS的api都会以处理二进制的方式来处理buf数组里面的数据，buf数组是用来保存二进制数据的，所以将其称为字节数组，因此SDS不仅能够支持文本数据，还能保存图片，音频，视频这样的二进制数据</p><blockquote><p>兼容部分C中的字符串函数</p></blockquote><p>因为都是字符串，二者有一些共同点和共同的需求，所以SDS可以使用一部分&lt;string.h&gt;库中的函数，这样就不用重复实现了</p><h3 id="字典-map" tabindex="-1"><a class="header-anchor" href="#字典-map" aria-hidden="true">#</a> 字典（map）</h3><p>redis中的map就跟Java中的HashMap差不多，存放键值对，并且有相应的扩容机制，,放入元素的时候也是先计算hash值，解决hash冲突也是采用链地址法，这里主要介绍一下redis中map的特别之处</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240829090119721.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>rehash</p></blockquote><p>随着不断操作，map中的元素会不断增多或者减少，为了让map的负载因子以及map大小维持在一个合理的范围，需要rehash，也就是重新散列，rehash是重新计算键的hash值和索引值，然后放到ht[1]的对应位置</p><p>map中有一个dictht类型的数组，大小为2，ht[1]就是为了rehash准备的（脑子里可以想象一下，有两个excel表格），rehash的过程是：</p><p>①为ht[1]分配空间，通常大一倍，也就是ht[1]的大小是ht[0]的两倍</p><p>②将ht[0]中的所有键值对rehash到ht[1]</p><p>③迁移完成之后，ht[0]空了，释放ht[0]，将ht[1]设置为ht[0]，然后再ht[1]新建一个空白的hash表，为下次rehash做准备</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240829091846458.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>渐进式rehash</p></blockquote><p>如果hash表中的数据很大的时候，一次性的rehash过程是很慢的，因此，为了避免rehash过程对性能产生影响，并不是采用一次性将所有的元素进行rehash，而是分多次，渐进式的rehash</p><p>渐进式rehash采用分治思想，将rehash的整个过程均摊到每个CRUD操作上，保证了使用体验</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240829092834225.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>map什么时候会扩容/收缩</p></blockquote><p><strong>扩容条件</strong>：</p><p>①服务器目前没有执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>,并且负载因子&gt;=1</p><p>②服务器目前正在执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>，并且负载因子&gt;=5</p><p><strong>收缩条件</strong>：负载因子&lt;0.1</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 负载因子 = hash表已保存节点数量 / hash表大小</span>
load_factor <span class="token operator">=</span> ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>.used / ht<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>.size
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>【<strong>问题</strong>】为什么正在执行正在执行<code>BGSAVE</code>或<code>BGREWRITEAOF</code>的时候，负载因子变得这么大？</p><p>为了尽可能的避免在子进程存在期间进行扩展操作</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20240829093942615.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,42),o=[p];function n(c,r){return a(),t("div",null,o)}const g=e(i,[["render",n],["__file","Redis设计与实现.html.vue"]]);export{g as default};
