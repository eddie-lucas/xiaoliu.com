import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e}from"./app-3d4993ca.js";const t={},o=e(`<h2 id="排序的分类" tabindex="-1"><a class="header-anchor" href="#排序的分类" aria-hidden="true">#</a> 排序的分类</h2><p>在mysql中，如果要进行排序，需要使用<code>order by</code>，排序过程中，如果排序字段命中索引，则利用索引排序，否则，使用文件排序（filesort）。在使用文件排序的时候，如果数据量少，则在内存中排序，如果数据量大，则利用磁盘文件进行外部排序，一般使用归并排序</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> 命中索引 <span class="token operator">=</span>》 索引排序
<span class="token keyword">else</span> 文件排序<span class="token punctuation">{</span>
    <span class="token keyword">if</span> 数据量少 <span class="token operator">=</span>》 内存排序
    <span class="token keyword">else</span> 利用磁盘外部排序
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="order-by无法使用前缀索引" tabindex="-1"><a class="header-anchor" href="#order-by无法使用前缀索引" aria-hidden="true">#</a> order by无法使用前缀索引</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">user</span>
<span class="token punctuation">(</span>
    <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">,</span>
    <span class="token identifier"><span class="token punctuation">\`</span>username<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> username<span class="token punctuation">)</span> <span class="token keyword">values</span>
                                   <span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">,</span><span class="token string">&#39;abcreopwropwrwop&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                   <span class="token punctuation">(</span><span class="token number">34567</span><span class="token punctuation">,</span><span class="token string">&#39;adcjjioeowporwek&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                   <span class="token punctuation">(</span><span class="token number">7896</span><span class="token punctuation">,</span><span class="token string">&#39;abdokfsldkflskflf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                   <span class="token punctuation">(</span><span class="token number">4567</span><span class="token punctuation">,</span><span class="token string">&#39;bafdjj0eolalks;lk&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment"># 创建前缀索引</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> username_index <span class="token keyword">on</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">order</span> <span class="token keyword">by</span> username<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241129192545062.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上面的查询结果看，可能第一感觉是使用了索引排序，因为是有顺序的，但是通过<code>explain</code>发现并没有使用索引排序，而是使用文件排序</p><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241129192823219.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因为前缀索引，只是字符串的前几个字符有序，但是整个字符串并不是有序的，所以使用order by对前缀索引进行排序，会使用文件排序</p><h2 id="文件排序" tabindex="-1"><a class="header-anchor" href="#文件排序" aria-hidden="true">#</a> 文件排序</h2><p>当使用<code>explain</code>分析sql发现执行计划的<code>extra</code>包含<code>using filesort</code>，说明使用了文件排序，如果排序的数据比较少，则直接在内存中通过<code>sort_buffer</code>排序，如果数据量超出了其大小，就需要利用磁盘临时文件排序，性能较差，可以通过<code>sort_buffer_size</code>来控制其大小</p><blockquote><p>当在内存中进行排序的时候，又可以分为<code>双路排序</code>和<code>单路排序</code></p></blockquote><ul><li>有一个参数<code>max_length_for_sort_data</code>，默认是4096字节，如果select列的数据长度超过了它（即select的单行数据），则将<strong>主键+排序字段放在sort_buffer中排序</strong>，排序过后，再通过主键id回表查询，将最后的结果返回给客户端</li></ul><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241129195353007.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>如果单行数据长度没有超过其大小，则将该行数据放入到sort_buffer进行排序，排序完成后，直接返回结果，不用进行回表</li></ul><figure><img src="https://gitee.com/eddie-lucas/images/raw/master/img/image-20241129195651275.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>磁盘文件临时排序</p></blockquote><p>如果数据量太大了，超过sort_buffer，说明内存放不下，需要利用磁盘文件进行外部排序，一般会使用归并排序，利用磁盘效率更低，可是调大<code>sort_buffer_size</code>，避免使用磁盘文件临时排序</p>`,18),p=[o];function c(i,l){return s(),a("div",null,p)}const u=n(t,[["render",c],["__file","MySQL中的排序.html.vue"]]);export{u as default};
